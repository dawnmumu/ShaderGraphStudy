# 效果分析
万国觉醒实现了白天、黑夜的时候建筑具有不同效果。我们来分析一下都有哪些效果。

- 在夜晚的时候整体叠加了一个颜色实现了夜晚的颜色效果
- 某些建筑有一些特别的位置可能需要叠加不同的颜色
- 窗户位置有单独的灯光效果、颜色实现
## 夜晚颜色叠加
我们先来实现一下简单的夜晚颜色叠加，其实只是简单的颜色叠加就是我们前面的示例shader的效果。这里我们用Shader Graph实现一下。

![image.png](https://note.youdao.com/yws/res/437/WEBRESOURCE2ae6afc60f7e2ecb8479e73a270f802e)
我们来修改一下NightColor的颜色，叠加一个浅蓝色。
![image.png](https://note.youdao.com/yws/res/435/WEBRESOURCE55e7b30ced3c7652af1120dc4c567489)
### Shader Graph的使用比较简单
- 新建两个属性一个Texture2D用来使用建筑主贴图、Color属性用来叠加晚上的效果。
- Sample Texture 2D 节点就是从主贴图中获取颜色值。
- Multiply 是用来做两个输入的相乘、对于颜色的叠加我们一般都是采用乘来做。

## 实现对建筑的局部控制
我们现在来做一下如何控制建筑的局部颜色变化，这里要引入一张控制贴图，这个也是我们做很多效果的常用方法。
图片在存储的时候是通过RGBA四个通道来存储的，而每个通道的值都是0-1之间的值，相当于每张贴图都给我提供了4个0-1的数组，那么我们就可以利用单个通道来控制是否显示，以及它的强弱。比如0就是不控制。
我这里之间使用了万国觉醒的贴图。我们在Unity中查看控制贴图可以看到
![image.png](https://note.youdao.com/yws/res/474/WEBRESOURCE4612f00898f3330dae6db053d9ef579b)
![image.png](https://note.youdao.com/yws/res/476/WEBRESOURCE19702db2495fed62bb997caab21c5dee)
![image.png](https://note.youdao.com/yws/res/478/WEBRESOURCEe9177eee4690d4d1b5e6dfa445a53700)
- R通道控制了哪些像素显示。我们之前看到贴图是有一个绿色的底色。那通过R通道我们就可以控制只显示建筑，而不显示背景绿色。
- G通道控制可以给塔顶等特殊区域配置不同的颜色。
- B通道控制力哪里晚上显示灯光
- 每个通道黑色的区域是值为0的区域。
### 我们在Shader Graph新建3个节点
- Texture2D节点 放控制贴图
- 两个Color节点，一个对应G通道颜色、一个对应B通道的颜色。

我们首先来做一下显示控制
![image.png](https://note.youdao.com/yws/res/483/WEBRESOURCEf6c8870eafe54b37c94c97cba49927d7)
我们可以看到现在已经只显示建筑和阴影部分了，绿色底色已经不显示了。
这里我们可以看到首先我们还是先对控制贴图进行解码。
这里我们用了一个新的节点Step
- Step 对于每个分量，如果输入 In 的值大于或等于输入 Edge 的值，则返回 1，否则返回 0。
之所以用这个节点是因为控制贴图的R通道是的值强弱是不一样的，如果我们之间用R通道去控制alpha通道，那么出来的建筑图会比较暗，因为所有的颜色都乘以了一个小于1的值。
Step的作用就是让我们控制大于我们设定的值，都返回1.来避免整体变暗。
同时这里我们发现一个小的设计，现在Step的值是0.01，有建筑和阴影显示。但实际上晚上的时候，我们不想要阴影，晚上没有阳光，建筑是不应该有影子的。我们现在把Step的Edge的值改为0.1看一下。
![image.png](https://note.youdao.com/yws/res/499/WEBRESOURCE8e629e1f3987a5f62a1dd30f74b00c80)
我们会看到已经没有影子了，只剩下建筑，这样比较符合晚上的效果。
- 这里有一点要注意一下Unlit Master新建出来默认的Surface的值是Opaque，也就是不支持半透效果。我们需要把值改为Transparent来支持半透，才能通过Alpha的值来控制贴图。
下面我们来对G、B通道做一下夜晚效果控制。
![image.png](https://note.youdao.com/yws/res/504/WEBRESOURCE0cb7c44e62243580e488a94ed41fe099)
## 控制灯光闪烁
我们知道为了营造灯光的效果，灯光在晚上一般会做成忽明忽暗的效果的。我们来继续实现一下。
实现起来也比较简单，Shader中我们需要控制由时间变化的值时，加入Time节点既可以了。
![image.png](https://note.youdao.com/yws/res/514/WEBRESOURCEb3181ab9ffca1c83c6d33e37f8c996b3)
实现的效果如下：
![image](https://note.youdao.com/yws/res/520/WEBRESOURCE1e580e776547e8ebaed7a295ee855da5)

这个效果可能有人会觉得闪烁的太慢了。
也有人觉得能不能只是强弱变化而不是直接变成没有。
我们继续修改一下。
![image](https://note.youdao.com/yws/res/527/WEBRESOURCEb3056b3a5ae72202f2163b8ad7197f9b)
下面看一下实现方式
![image.png](https://note.youdao.com/yws/res/532/WEBRESOURCE070597e05158f7294910baa024722712)
这里我们加入了一个Vector1的节点来控制Speed。
这里使用了两个新的节点：
- Sine 返回输入 In 的值的正弦值。
- Remap 根据输入 In 值在输入 In Min Max 的 x 和 y 分量之间的线性插值，返回输入 Out Min Max 的 x 和 y 分量之间的值。

# 手写代码
按照上面思路直接写就好了。
```
Shader "Unlit/DayNightBuilding"
{
    Properties
    {
        [NoScaleOffset]_MainTex("MainTexture", 2D) = "white" {}
        _Color("NightColor", Color) = (0, 0, 0, 0)
        [NoScaleOffset]_Control("Control", 2D) = "white" {}
        _RCut("RCut",Float)=0.01
        _GColor("GColor", Color) = (0, 0, 0, 0)
        _BColor("BColor", Color) = (0, 0, 0, 0)
        _Speed("Speed", Float) = 10

        
    }
    SubShader
    {
        Tags {"RenderPipeline"="UniversalRenderPipeline" "RenderType"="transparent" "Queue" = "transparent"  }   
        Blend SrcAlpha OneMinusSrcAlpha 
		Pass {
			HLSLPROGRAM  
            #pragma vertex vert
            #pragma fragment frag
            #pragma target 3.0
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

            struct appdata_t {
                float4 vertex : POSITION;
                float2 texcoord : TEXCOORD0;
            };
        
            struct v2f {
                float4 vertex : SV_POSITION; 
                float2 texcoord : TEXCOORD0; 
            };
            
            sampler2D _MainTex,_Control;  
            CBUFFER_START(UnityPerMaterial)
            half _Speed,_RCut;
            half4 _Color,_GColor,_BColor;
            float4 _MainTex_ST,_Control_ST;
            CBUFFER_END
            void Unity_Remap_half(half In, half2 InMinMax, half2 OutMinMax, out float Out)
            {
                Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
            }
            v2f vert (appdata_t v)
            {
                v2f o;
                o.vertex = TransformObjectToHClip(v.vertex.xyz); 
                o.texcoord = TRANSFORM_TEX(v.texcoord, _MainTex);
                return o;
            }


            half4 frag (v2f i) : SV_Target
            {
                half4 finalCol = tex2D(_MainTex,i.texcoord);
                finalCol=finalCol*_Color;
                half3 controlrgb=tex2D(_Control,i.texcoord).rgb;
                finalCol+=_GColor*controlrgb.g;
                half remap;
                Unity_Remap_half(sin(_Time.y*_Speed),half2(-1,1),half2(0.5,1),remap);
                finalCol+=_BColor*controlrgb.b*remap;
                finalCol.a=step(_RCut,controlrgb.r);
                return finalCol;
            }
			ENDHLSL
		}
    }
}

```





