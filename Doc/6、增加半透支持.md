# 如何增加半透支持
我们在实际项目中，很多情况下渲染都是需要支持半透材质的。
我们之前的shader大家如果尝试过，可能会发现是不支持半透材质的。
我们继续修改之前的示例shader
首先将Tags 中的RenderType 和Queue的值都改为transparent,也就是默认支持半透渲染。
加入Blend指令，用来指明半透物体之间如何混合。
```
Shader "Mark/Unlit" {  //名字
	Properties {
		_MainTex ("Base (RGB)", 2D) = "white" {} //定义贴图属性
	    _Color("Main Color", Color) = (1,1,1,1)     //定义一个主颜色
	}

	SubShader {
		Tags {"RenderPipeline"="UniversalRenderPipeline" "RenderType"="transparent" "Queue" = "transparent"}  
		//指明Shader为URP shader
        Blend SrcAlpha OneMinusSrcAlpha  //半透混合模式
		Pass {
			HLSLPROGRAM   //指明这是一个HLSL代码片段
            #pragma vertex vert   //定义顶点着色器的函数名
            #pragma fragment frag   //定义片段着色器的函数名
            #pragma target 3.0   //定义支持的opengl的版本
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"   //引入core库
            //定义输入数据结构
            struct appdata_t {
                float4 vertex : POSITION;   //顶点坐标
                float2 texcoord : TEXCOORD0;    //贴图
            };
            //定义输出数据结构
            struct v2f {
                float4 vertex : SV_POSITION; //顶点坐标  必须有
                float2 texcoord : TEXCOORD0; //uv坐标
            };
            //定义和属性定义中同名的属性，以便在代码片段中使用。
            sampler2D _MainTex; 
            CBUFFER_START(UnityPerMaterial)
            half4 _Color;
            float4 _MainTex_ST;  //_ST是一个内置的规则、这个存储的是贴图的Tilling和Offset
            CBUFFER_END
            v2f vert (appdata_t v)
            {
                v2f o;
                o.vertex = TransformObjectToHClip(v.vertex.xyz);     //可以简单的理解为将世界坐标转换到屏幕坐标。
                o.texcoord = TRANSFORM_TEX(v.texcoord, _MainTex); //获取贴图的UV
                return o;
            }

            half4 frag (v2f i)
            {
                half4 col = tex2D(_MainTex,i.texcoord);  //获取贴图在该顶点的颜色信息
                return col*_Color;   //贴图颜色混合叠加的主色。
            }
			ENDHLSL
		}
	}
}
```
![image.png](https://note.youdao.com/yws/res/362/WEBRESOURCEdf4664451fcc5455d03de2f4a2cd0ba4)
我们为shader选择了一张系统的mark的图片，就是只有对钩的半透明图片。
这个时候我们发现渲染的物体并没有变成半透明状态。
这是因为我们使用了之前已经创建好的材质球，在材质球上默认Render Queue并没有改变，我们需要手工修改一下。
我们将材质球上的Render Queue属性修改为3000。（2500以上为半透渲染通道，低于2500是不会进行半透渲染的。）
![image.png](https://note.youdao.com/yws/res/371/WEBRESOURCEcd8fde3951c84c78f3b05cbb5be3f800)
这样我们支持半透渲染的Shader就修改好了。
# Blend 混合
混合用于生成透明对象。
渲染图形时，在执行所有着色器并应用所有纹理后，像素将写入到屏幕。这些像素与已有像素的组合方式由 Blend 命令控制。
也就是说每个半透对象如何混合是由Blend命令控制的。
## 语法
Blend Off：关闭混合（这是默认值）

Blend SrcFactor DstFactor：配置并启用混合。生成的颜色将乘以 SrcFactor。屏幕上的已有颜色乘以 DstFactor，然后将这两个值相加。

Blend SrcFactor DstFactor, SrcFactorA DstFactorA：同上，但使用不同系数来混合 Alpha 通道。

BlendOp Op：不将混合颜色相加，而是对它们执行不同的操作。

BlendOp OpColor, OpAlpha：同上，但是对颜色 (RGB) 通道和 Alpha (A) 通道使用不同的混合操作。

此外，您还可以设置上层渲染目标混合模式。当 使用多渲染目标 (MRT) 渲染时，上面的常规语法 将为所有渲染目标设置相同的混合模式。以下语法可以为各个渲染目标设置不同的混合模式，其中 N 是渲染目标索引（0 到 7）。此功能适用于大多数现代 API/GPU（DX11/12、GLCore、Metal 和 PS4）：

- Blend N SrcFactor DstFactor
- Blend N SrcFactor DstFactor, SrcFactorA DstFactorA
- BlendOp N Op
- BlendOp N OpColor, OpAlpha
- AlphaToMask On：开启 alpha-to-coverage。使用 MSAA 时，alpha-to-coverage 会根据像素着色器结果 Alpha 值按比例修改多重采样覆盖率遮罩。这通常用于比常规 Alpha 测试更少锯齿的轮廓；对植被和其他经过 Alpha 测试的着色器非常有用。

## 混合运算
可使用以下混合运算：

- Add	将源和目标相加。
- Sub	从源减去目标。
- RevSub	从目标减去源。
- Min	使用源和目标中的较小者。
- Max	使用源和目标中的较大者。
这里只列出了移动设备支持的参数，更多的运算符可以去查看Unity的手册。
## 混合系数
以下所有属性对 Blend 命令中的 SrcFactor 和 DstFactor 都有效。源是指计算所得颜色，目标是指屏幕上已有的颜色。如果 BlendOp 在使用逻辑运算，则将忽略混合系数。
|||
|-|-|
|One	|值为 1 - 让源或目标颜色通过。|
|Zero	|值为 0 - 删除源或目标值。
|SrcColor	|此阶段的值乘以源颜色值。
|SrcAlpha	|此阶段的值乘以源 Alpha 值。
|DstColor	|此阶段的值乘以帧缓冲区源颜色值。
|DstAlpha	|此阶段的值乘以帧缓冲区源 Alpha 值。
|OneMinusSrcColor	|此阶段的值乘以（1 - 源颜色）。
|OneMinusSrcAlpha	|此阶段的值乘以（1 - 源 Alpha）。
|OneMinusDstColor	|此阶段的值乘以（1 - 目标颜色）。
|OneMinusDstAlpha	|此阶段的值乘以（1 - 目标 Alpha）。
## 详细信息
以下是最常见的混合类型：
```
Blend SrcAlpha OneMinusSrcAlpha // 传统透明度
Blend One OneMinusSrcAlpha // 预乘透明度
Blend One One // 加法
Blend OneMinusDstColor One // 软加法
Blend DstColor Zero // 乘法
Blend DstColor SrcColor // 2x 乘法
```